---
title: "면접 후기 (1)"
date: 2026-02-19 21:00:00 +0900
categories: [Interview, CS]
tags: [interview, memory]
toc: true
---

## 요약

면접장에서 버벅였던 질문들을 면접 끝나고 생각해보고있다.
아직도 어렵게 느껴지는 것도 있고, 이렇게 대답했어야 하는데... 하는 것도 있다.
그리고 현재의 내가 부족한 부분에 대해 알게 되었고
면접관의 관점에서 생각해보는 시간을 가졌다.
이곳엔 내가 잘 대답했던 질문들은 제외하고
아직도 머릿속에서 날 괴롭히는 망한 답변 위주로 정리해보겠다.


---

## 아직도 어렵게 느껴지는 질문들

### JVM / GC

“JVM이 뭔가요? GC는 어떻게 동작하나요?”라는 질문이 나왔을 때, 
나는 “GC는 동적 할당된 메모리를 쓸어간다” 정도로 말했고 JVM에 대해선 이상하게 얼버무리고 말았다. 
지금도 그 질문을 떠올리면 막막함이 먼저 온다.
구조를 이해했는지, 설명을 할 수 있는지 아직 확신이 없다.

### 메모리 1GB로 10GB 정렬

“RAM이 1GB인데 10GB 데이터를 정렬해야 하면?”  
잘 모르겠지만 divide and conquer 방식의 병합정렬이 떠오른다 라고 대답했지만
면접관님이 “근데 그것도 메모리에 올려야 가능하잖아요 ㅋㅋ” 라고 하셔서 난 아;; 죄송합니다... 하고,
대답을 잇지 못했다.  
이건 아직 내 머릿속에 정확한 그림이 없는 질문이다.
면접관님께 질문을 해가면서 풀어냈어야 하는데... 하는 아쉬움은 있다. 그냥 내가 포기해버린 느낌이다.
다음번에 어려운 질문이 오면 면접관과 소통해가면서 풀어보고싶다.

### 네트워크 관점

1. 100MB파일과 10MB파일 전송. 무엇이 빠른가?,
2. 100MB 한 파일 전송 vs 1MB 100개파일 전송 무엇이 빠른가?

1번 질문에 나는 10MB 파일이라고 답했고 왜 그러하냐고 물어오셨다.
네트워크 대역폭은 물리적으로 정해져있고 대역폭의 레벨 하에선 크기가 작은 파일이 더 빠르게 전송될것 이라고 답했다.
(이거 맞나?...)

2번 질문에 나는 100MB 한 파일이 빠를 것이라고 했고, 다시 왜 그러하냐 물어오셨다.
1MB파일 100개의 경우 I/O 시스템 콜이 100배 많기 때문이라고 대답했다.
면접관님께선 네트워크 관점으로 설명해보라고 하셨고, 난 잘 모르겠다고 대답했다.

네트워크도 꼭 제대로 공부하고 이해하고 구현해보아야겠다...


---

## 이제는 대답할 수 있을 것 같은 질문들

### 메모리 구조

메모리에대해 이해하고 있는지 질문이 들어왔다.
스택, 힙, 데이터 섹션, 코드 섹션 등 메모리의 각각의 영역에 대해 설명해 보라고 하셨다.

힙엔 동적할당된 개체들이 들어간다, 데이터 섹션엔 static 키워드가 붙은 변수들이 들어간다,
스택은 프로그램 카운터와 맞물려 함수 호출스택이 쌓였다 없어졌다 반복한다,
코드 섹션에 대해선 잘 모르겠다. 아마도 코드가 들어가는 영역인가요? 라고 얼버무렸다...

미래의 나는 아래와 같이 대답할 수 있을까?

> 프로세스가 실행되면 운영체제는 그 프로그램을 하나의 가상 주소 공간에 올려 두고, 그 공간을 역할에 따라 여러 영역으로 나눠 사용합니다. 일반적으로 코드(Code/Text) 영역, 데이터(Data/BSS) 영역, 힙(Heap), 스택(Stack) 영역으로 구분합니다.  
>  
> 코드 섹션은 컴파일된 기계어 명령어가 저장되는 곳입니다.  
> CPU가 실제로 가져와 실행하는 명령어들이 들어 있으며, 보통 읽기와 실행 권한만 있고 쓰기 권한은 제한됩니다.  
> 이는 실행 중 코드가 임의로 수정되는 것을 막아 안정성과 보안을 확보하기 위함입니다.  
>  
> 데이터 영역은 전역 변수와 static 변수가 저장되는 공간입니다.  
> 이 중에서 초기값이 명시된 전역/정적 변수는 Data 영역에,  
> 초기값이 없는 변수는 BSS 영역에 배치됩니다.  
> BSS 영역의 변수들은 프로그램 시작 시 0으로 초기화됩니다.  
> 이 영역의 변수들은 프로그램이 시작될 때 메모리에 올라가고, 프로그램이 종료될 때까지 유지됩니다.  
>  
> 힙 영역은 런타임 동안 동적으로 할당되는 메모리가 위치하는 곳입니다.  
> C의 malloc, C++의 new, 자바의 객체 생성 등이 이 영역을 사용합니다.  
> 힙은 필요에 따라 크기가 확장될 수 있으며, 명시적으로 해제하거나 가비지 컬렉터가 관리합니다.  
>  
> 스택 영역은 함수 호출과 함께 생성되는 스택 프레임이 쌓이는 공간입니다.  
> 각 함수 호출 시 매개변수, 지역 변수, 리턴 주소, 일부 레지스터 값 등이 저장됩니다.  
> 함수가 반환되면 해당 프레임은 제거됩니다.  
> 스택은 단순히 스택 포인터를 이동시키는 방식으로 관리되기 때문에 매우 빠르게 할당과 해제가 이루어집니다.  
> 또한 각 스레드는 자신만의 스택을 가지므로, 스레드 간 지역 변수는 서로 영향을 주지 않습니다.  
>  
> 정리하면,  
> 코드 영역은 실행 명령어가 위치하고,  
> 데이터 영역은 전역 및 정적 데이터가 저장되며,  
> 힙은 동적 객체가 저장되는 공간이고,  
> 스택은 함수 호출 단위의 임시 데이터가 저장되는 공간입니다.  
>  
> 이 구조를 통해 프로그램은 정적 데이터, 동적 데이터, 실행 흐름을 체계적으로 관리할 수 있습니다.


### 리스트 셋 맵 에 대해 설명해보세요.

이전 질문으로 배열과 링크드리스트에 대해 물어오셔서
나름 잘 대답했다.

근데 이어진 “리스트, 셋, 맵에 대해 설명해보세요.” 질문에서 멈칫했다.
어? 왜 물어보신걸 또 물어보시지? 라고 생각하여
리스트라는게 배열을 말씀하시는건가요? 하고 이상한 질문을 해버렸고
배열과 해시맵에 대해 설명해버리고 말았다.

지금은 그 질문의 의도를 알 것 같다.

Java의 컬렉션 프레임워크에 대해 물어보신 것 같다. ㅠㅠ

> 자바 컬렉션 프레임워크는 객체들을 저장하고 관리하기 위한 표준 자료구조 모음입니다.
> List는 순서가 있고 중복을 허용하며,
> Set은 중복을 허용하지 않는 집합 구조이고,
> Map은 Key-Value 형태로 데이터를 저장하며 Key는 중복될 수 없습니다.

### 컴파일 언어 vs 인터프리터 언어

컴파일 언어와 인터프리터 언어의 차이를 설명하라고 했을 때  
컴파일 언어는 컴파일, 어셈블, 링킹 과정을 거쳐 기계어로 번역된 파일을 CPU가 읽는 방식이고,
인터프리터 언어는 한줄씩(이것도 참 모호한 표현같다 ㅠㅠ) 기계어로 번역하여 CPU가 명령어를 해석하고 실행한다고 답했다.

자바는 컴파일과 인터프리팅이 섞여 있다고 대답했지만,
정확한 흐름을 말하지는 못했다.

> 컴파일 언어는 소스 코드를 실행 전에 한 번에 기계어로 번역하여 실행 파일을 생성하는 방식입니다.
> 컴파일, 어셈블, 링킹 과정을 거쳐 CPU가 직접 실행 가능한 바이너리 파일이 만들어지며,
> 실행 시에는 별도의 번역 과정 없이 바로 CPU가 기계어를 처리합니다.
> 반면 인터프리터 언어는 소스 코드를 실행 시점에 해석하지만,
> CPU가 직접 소스를 실행하는 것은 아니며, CPU는 인터프리터 프로그램의 기계어를 실행합니다.
> 인터프리터는 소스를 내부적으로 분석하고, 그 결과에 따라 동작을 수행합니다.
> 흔히 “한 줄씩 실행한다”고 표현하지만, 실제로는 토큰화, 파싱, 바이트코드 생성 등을 거쳐 인터프리터가 처리합니다.
> 자바는 이 두 방식이 결합된 구조입니다.
> 자바 소스 코드는 먼저 컴파일러에 의해 바이트코드(.class 파일)로 컴파일됩니다.
> 이 바이트코드는 특정 CPU의 기계어가 아니라 JVM이 이해하는 중간 코드입니다.
> 실행 시에는 JVM이 이 바이트코드를 해석하거나, JIT(Just-In-Time) 컴파일러를 통해
> 자주 실행되는 부분을 네이티브 기계어로 변환하여 실행합니다.
> 따라서 자바는 컴파일과 인터프리팅, 그리고 런타임 컴파일을 모두 포함하는 하이브리드 구조라고 할 수 있습니다.


### Spring 빈 / 빈 생명주기

Spring 빈 / 빈 생명주기에 대해 설명하라고 하셨다.
빈은 서버가 뜰때 같이 뜨는 “객체” 정도로 답했고,  
생명주기는 “서버 뜰 때 생성되고 소멸은 잘 모르겠다”고 했다.
지금 돌아보면 너무 허무한 대답이었다...

Java/Spring 개발자라고 했지만 Spring에대해 너무 쉽게 생각하고 있었다.
민망했다.

### 인터페이스 vs abstract 클래스

인터페이스는 하나의 함수 시그내처에 여러 구현을 위해 사용하고,
abstract는 그것을 포함해서 객체화를 막기 위해 사용해 보았다고 대답했다.

지금 생각해보면 너무 아쉬운 대답이었다.

나중에 누군가가 물어보면

> 인터페이스는 행위 중심 추상화이고, 추상 클래스는 구조 중심 추상화.
> ...로 이어지는 대답을 해보고 싶다.

---


위 질문들 외에도
싱글턴 / 페이지 폴트 / 콜 바이 밸류 콜 바이 래퍼런스 / 깊은 복사 얕은 복사 / 동시성 / 락
등등 여러 질문을 받았다...

## 정리

A,B,C 세 분의 면접관이 계셨고,
그중 A 면접관님은 why why why 로 이어져 해당 개념의 본질까지 건드리는 꼬리질문을 하셨다.
A 면접관님의 좋은 질문들이 정말 많았지만, 제대로 답한 건 거의 없었다.

다음에도 이런 면접 볼 기회가 생긴다면
면접관을 실망시키고 싶지 않다.

---
